# Copyright (c) 2021 Oracle Corporation
# Licensed under the Universal Permissive License v 1.0
# as shown at https://oss.oracle.com/licenses/upl/

# bengsig  01-sep-2022 - get pool sizes at end
# bengsig  31-aug-2022 - Use parameter for interval between saves
# bengsig  23-aug-2022 - Save buffer cache, shared_pool sizes
# bengsig  10-may-2022 - rename awr.rwl to oltpawr.rwl
# bengsig  03-feb-2022 - Add $longoption:event-notify
# bengsig  02-feb-2022 - Awr snapshot markers
# bengsig         2017 - Creation

# Do anything system related

$longoption:event-notify

$include:"parameters.rwl"
$include:"systemdb.rwl"
$include:"results.rwl"
$include:"oltpawr.rwl"
$include:"timemodel.rwl"
$include:"instdist.rwl"
$include:"ashstep1.rwl"

file plotfile;

# Write database instance distribution to plot file

double threads sum maxtot := 0; # see below

file inacdistfile;

# Here's the procedure that tells
# how many sessions are in each instance
procedure inacdist() nostatistics

  # These are used to regularly sow the number
  # of sessions connected to each instance
  integer dist_inst, dist_count, tot;
  string(20) dist_usrn;
  string action;
  sql inst_dist_sql
    select inst_id, count(*) /*, username*/, nvl(action,'UNUSED') from gv$session
    where username like upper(:1)
    group by inst_id /*, username*/, action
    order by inst_id /*, username*/, action
    /
    #define 1 dist_inst, 2 dist_count, 3 dist_usrn, 4 action;
    define 1 dist_inst, 2 dist_count, 3 action;
    bind 1 rwl_run_like;
    array 8;
  end;

  inacdistfile := ">>" || resultsdir || subdir || runnumber||"/inacdist.txt";
  tot := 0;
  for inst_dist_sql loop
    printf "runnumber %d at %8.1fs %1d %3d %s\n", runnumber
    , runseconds , dist_inst , dist_count , action ;
    fprintf inacdistfile, "%8.1f %2d %3d %s\n"
    , runseconds, dist_inst, dist_count, action;
    tot := tot+dist_count;
  end;
  printf "runnumber %d at %8.1fs   %3d total\n", runnumber, runseconds, tot;
  fflush stdout;
  inacdistfile := null;

  # Note that the following only works because we know that only
  # one thread is running this code
  if tot > maxtot then
    maxtot := tot;
  end if;
end;

procedure tellnoawr() nostatistics
  if runperiod<125 or !doawr then
    printline "no awr gathered";
  end;
end;

# Do the system stuff
run 
  # start the real workers

  # gather awr in one of the processes if
  # runtime is at least two minutes
  threads (doawr and runperiod>=125)
    double awrbb_tim, awrbe_tim, awreb_tim, awree_tim;
    for count 1 start 5 loop
      awrbb_tim := runseconds;
      beginawr() at systemdb;
      awrbe_tim := runseconds;
    end loop;
    for count 1 start runperiod-10 loop
      awreb_tim := runseconds;
      endawr() at systemdb;
      awree_tim := runseconds;
    end loop;
    awrtim_save(awrbb_tim, awrbe_tim, awreb_tim, awree_tim) at rwloadsim;
  end;

  # Do this when runperiod is too short in stead of awr
  threads (runperiod<125 or !doawr) at systemdb
    wait(5); tellnoawr();
    for count 1 loop
      inacdist();
    end loop;
  end;

  # make some reporting on the number of sessions in the database
  threads 1 at systemdb
    for every 10 stop runperiod loop
      inacdist ();
    end loop;
  end threads;

  # create a thread that saves time model data from the
  # database; do this in one process only
  threads 1 at rwloadsim
    # wait 1 has too much noise and ragged graphs
    # keep in sync with --flush-every in run.sh for the gnuplot input
    for every 2 stop runperiod+2 loop
      timemodel_save(); 
      instdist_save(rwl_run_like);
    end loop;
  end threads;

  # save the buffer cache and shared pool sizes every minute
  threads 1 at rwloadsim
    double pool_rs, pool_mb1, pool_mb2, pool_mb3, pool_mb4, pool_mb5, pool_mb6, pool_mb7, pool_mb8;
    string pool_name;
    sql getpoolsizes
      select pool_name 
      , pool_mb1, pool_mb2, pool_mb3, pool_mb4, pool_mb5, pool_mb6, pool_mb7, pool_mb8
      from
	(
	select inst_id 
	, decode(nvl(pool,name)
	  , 'buffer_cache','BCACHE'
	  , 'shared pool','SHAREDP') pool_name
	, bytes/1024/1024 sp_megabytes
	from gv$sgastat
	where nvl(pool,name) in ('buffer_cache','shared pool')
	)
      pivot(sum(sp_megabytes) 
      for inst_id in
	(1 as pool_mb1
	,2 as pool_mb2
	,3 as pool_mb3
	,4 as pool_mb4
	,5 as pool_mb5
	,6 as pool_mb6
	,7 as pool_mb7
	,8 as pool_mb8
	)
      )
      /
      define sql;
      array 10;
    end;

    sql inspoolsizes
      insert into sysres(runnumber, second, resname
      , val1, val2, val3, val4, val5, val6, val7, val8)
      values (:runnumber, :pool_rs, :pool_name
      , :pool_mb1, :pool_mb2, :pool_mb3, :pool_mb4, :pool_mb5, :pool_mb6, :pool_mb7, :pool_mb8)
      /
      bind sql;
      array 10;
    end;
    for every pool_size_interval stop runperiod loop
      pool_rs := runseconds;
      for getpoolsizes at systemdb
      loop
        inspoolsizes;
      end loop;
      commit;
    end loop;
    # gather end values as well
    pool_rs := runseconds;
    for getpoolsizes at systemdb
    loop
      inspoolsizes;
    end loop;
    commit;
  end threads;

  # Create the SQL that will collact top ash data
  threads 1 
    for count 1 start runperiod loop
      ashstep1($1) at rwloadsim;
    end loop;
  end threads;
end run;

plotfile := ">>" || resultsdir || subdir || runnumber || "/env";
writeline plotfile, "y2max="||maxtot*1.1;
plotfile := null;
