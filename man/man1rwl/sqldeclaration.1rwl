.TH sqldeclaration "1rwl" "September 2020" "RWP*Load Simulator" "Program Syntax"
.SH NAME
sqldeclaration \- RWP*Load Simulator declaration of SQL statements
.SH SYNTAX
.nf
sqldeclaration ::=
\fBsql\fR identifier
  [ sqltext ]
  { sqlspecification \fB;\fR }
\fBend\fR [ \fBsql\fR | identifier ]

immediatesql ::=
\fBsql\fR \fBexecute\fR
  sqltext
  { sqlspecification \fB;\fR }
\fBend\fR [ \fBsql\fR ]

sqltext ::=
  SQLtext \fB;\fR newline
| SQLtext newline whitespace ( \fB/\fR | \fB.\fR ) newline
| PLSQLblock newline whitespace ( \fB/\fR | \fB.\fR ) newline
| \fBfile\fR concatenation \fB;\fR
| concatenation \fB;\fR

sqlspecification ::=
  \fBbind\fR bindspecification { \fB,\fR bindspecification }
| \fBbindout\fR bindspecification { \fB,\fR bindspecification }
| \fBdefine\fR integer identifier { \fB,\fR integer identifier }
| \fBbind\fR \fBsql\fR
| \fBdefine\fR \fBsql\fR
| \fBarray\fR [ \fBdefine\fR ] expression
| \fBignoreerror\fR
| \fBcursorcache\fR
| \fBnocursorcache\fR

bindspecification ::=
| string identifier
| integer identifier
| \fB:\fR identifier

.fi
.SH DESCRIPTION
In rwloadsim, SQL statements can be declared as variables that subsequently
can be used in several different places.
The typical use of a SQL variable is to execute it as such,
which normally is done for DML, DDL, PL/SQL or single row queries,
or if it is a query without a known number of rows to execute it in a cursor loop.
Using a variable is suggested if you need to execute the SQL from different places
in your rwloadsim program, and this was the only possibility in previous versions
of rwloadsim.
.P
Starting with version 3 of rwloadsim, there is no requirement to first declare
a variable that you subsequently exeucte, 
as you can also immediatedly execute SQL once or in a cursor loop.
This approach will make programming easier for SQL
that is only used a single place in your rwloadsim program.
.P
The \fBsql\fR keyword initiates a declaration of a static or dynamic SQL statement
and the declaration potentially provides a list of variables used
for bind, define and bindout in addition to several other attributes.
Each such attribute (such as bind) must be terminated by a ;.
and the complete declaration must be finished by the keyword
\fBend\fR which can be optionally followed by \fBsql\fR
or by the name of the sql.
.P
The \fBsql execute\fR keywords initiate immediate execution of a SQL statement and can similarly
have attibutes.
.P
.SH "STATIC SQL"
The keyword \fBsql\fR is followed by the name of the variable, and the actual text of the SQL
or PL/SQL must follow.
There are three ways to provide the SQL text:
.TP 4
1.
Have rwloadsim scan for SQL or PL/SQL similar to how SQL*Plus does it.
This is the preferred approach.
.TP 4
2.
Provide the SQL or PL/SQL text in a named file.
.TP 4
3
Have a concatenation (including just a string constant) that is the full SQL text.
This is primarily useful if the full SQL or PL/SQL text is created from concatenating
several text strings or variables containing text strings.
Note that local variables cannot be used for this.
If you need SQL inside a procedure that contains values from local variables,
use the dynamic sql approach of rwloadsim.
Also note that if you use this approach, any " needed in your SQL text must 
be prefixed by \\ for it to become part of a string in rwloadsim.
.PP
The RWP*Load Simulator starts scanning for SQL text when seeing any of these keywords:
\fBselect\fR, 
\fBdelete\fR, 
\fBupdate\fR, 
\fBinsert\fR, 
\fBmerge\fR, 
\fBcreate\fR, 
\fBdrop\fR, 
\fBalter\fR, 
\fB/*\fR
and it starts scanning for PL/SQL text when seeing any of these keywords:
\fBdeclare\fR, 
\fBbegin\fR, 
\fBcall\fR, 
\fB--\fR.
In both cases, the keyword is not case sensitive as opposed to all other situations
where the rwl language is case sensitive.
Scan for SQL or PL/SQL is finished by a
.B /
or
.B .
on a line by itself potentially preceded by white space.
The scan for SQL can also be finished by having a
.B ;
at the end of a line.
As opposed to SQL*Plus, rwloadsim does not terminate scanning for SQL or PL/SQL at an empty line.
.P
If you need to use a SQL statement or PL/SQL block that is not started by one of 
the keywords shown, you must use an initial comment starting with /* for SQL or
with -- for PL/SQL
to make rwloadsim perform the scan for SQL or PL/SQL.
.P
Note that the SQL keyword 
.B with
is not among those that rwloadsim knows as a starter keyword for SQL, so if you have a
SQL statement starting with the
.B with
keyword, you must write it
.B /**/ with
or have the complete SQL text in a separate file and use the 
.B file
keyword as explained below.
.P
Rwloadsim does not make any modifications to either, so the complete text including
any newline, white-space, etc from the initial keyword and until the terminator becomes
the text that eventually will be the argument to OCIStmtPrepare2.
.P
If you have a need for comments inside the SQL or PL/SQL, use the appropriate 
syntax from those languages, i.e. -- or /* */; a # will be part of the SQL or PL/SQL text.
.P
As an alternative to embed your SQL or PL/SQL text directly in your rwl source file
you can use the \fBfile\fR keyword followed by a concatenation that resolves to a 
file name.  The file will be opened and the SQL or PL/SQL text will be read from it;
the file should not have either of the terminators ; . /.
.P
The last alternative is to have a concatenation followed by ; in which case the concatenation
will be the SQL or PL/SQL text.
.SH "DYNAMIC SQL"
If there is no SQL or PL/SQL provided, neither directly in your rwl source file nor
being read from a file, the declared sql statement is dynamic and the text must 
be provided using the \fBmodify sql\fR command.
Note that the rwl language (presently) does not have a mechanism to 
.I describe
the actually provided SQL statement.
You can neither get the type of the sql (e.g. query or DML), nor the list of
select list elements or bind variables.
During declaration of a dynamic sql, you can provide bind, bindout or define variables
that are known to be present for all executions regardless of the actual SQL text.
During later execution, you can add extra variables as needed using the
.B modify sql
command.
.SH "ATTRIBUTES"
In most cases, you will need to provide attributes for your sql statement.
These include variables use for bind and/or define, array sizes, use of the cursor 
cache, etc.
.P
\fBbind placeholder variable\fR 
.RS 4
Bind the named variable as input to a placeholder in your sql text.
The placeholder is either an integer which results in bind-by-position or is a text string
which results in bind-by-name in which case the first character of the text must be a colon.
This can e.g. be used in the values clause of an insert statement, or in the where clause
of a query.
.P
You can replace the placeholder by a single \fB:\fR in which case it will be bind-by-name
where both the name of the placeholder and the name of the variable it is bound to is
the identifier following the colon.
.RE
.P
\fBbindout placeholder variable\fR 
.RS 4
Bind the named variable as output from a placeholder in your sql text.
This can e.g. be used as an output variable in a PL/SQL block
or in the returning clause of an insert statement.
Bindout cannot be used in combination with the array interface.
As for normal bind, you can use bind-by-position or bind-by-name and you can
replace the placeholder with \fB:\fR.
.RE
.P
\fBdefine position variable\fR 
.RS 4
Define the named variable as select-list-element of a query.
The integer position is the number in the select list, and the call results in a
define-by-position.
.RE
.P
.nf
\fBbind sql\fR 
\fBdefine sql\fR 
.fi
.RS 4
These options will turn on implicit bind respectively define for the SQL statement; 
both can be used as needed.
See below under IMPLICIT BIND/DEFINE for details.
.RE
.P
\fBarray size\fR 
.RS 4
Set the number of rows in the array interface.
For cursor loops, the default is to use an array sized by memory, and for anything
else, the default is 1.
For cursor loops, the array interface is handled using the features of Oracle Call
Interface, unless you use the \fBarray define\fR keywords in which case the
array is allocated by rwloadsim.
For DML, the array interface is allocated by rwloadsim and is automatically flushed 
as needed during commit or rollback.
.RE
.P
\fBignoreerror\fR 
.RS 4
Ignore any error during execution of the sql statement.
You should code error handling yourself using the
\fBoraerror\fR and/or \fBoraerrortext\fR variables.
.RE

.P
\fBnocursorcache\fR 
.RS 4
By default, rwloadsim will use the cursor cache provided by Oracle Call Interface.
It may be beneficial to turn this off for sql that is only executed once.
.RE
.SH "IMPLICIT BIND/DEFINE"
Typically, you will use \fBbind\fR and/or \fBdefine\fR
to associate variables in your rwl program
with bind-variables (a.k.a. placeholders) or select list elements.
To ease your rwl program writing, you can have rwloadsim do this implicitly,
which it does by matching names of placeholders or select list elements
in your SQL statement
to declared variables in your rwl program.
If a match is found, the mapping will be done and the appropriate
bind or define 
is handled without an explicit \fBbind\fR and/or \fBdefine\fR.
.P
This implicit matching can be specified as part of your
SQL statement declaration or
it can be enabled generally via directives.
The implicit matching takes place once during the first
execution of your SQL statement,
and the binds and/or defines done will subsequently be used
for any subsequent execution.
The name of the select list element or bind variable found
in the SQL statement will be
converted to lowercase before matching to a variable name.
This mechanism can be 
turned off using the
.B $implicit:keepcase
directive.
.P
If your SQL statement has bind variables (e.g. :1, :2, etc) or select list
elements (e.g. expressions), that cannot possibly be matched to any identifiers,
you need to either use explicit bind or define or to replace a bind variable by
a proper name or give an alias to the select list element.
.P
Any bindout required must be explicitly done,
and implicit define cannot be used
in combination with array define.
.P
You can combine explicit and implicit bind/define,
in which case the implicit behavior will only apply to those
not already done explicitly. 
It is, however, suggested that except for bindout,
you do not combine the two.
.P
Queries with implicit define and without an explicit 
.B array
will use OCI prefetch based on memory set to 100kB.
.P
You can also use implicit bind/define with dynamic SQL,
in which case any implicitly 
created binds and/or defines are released when
.B modify sql release
is being performed.
.SH "IMMEDIATE SQL"
In version 3 of rwloadsim, you can use the keyword \fBexecute\fR rather than an identifier,
causing your SQL to be unnamed and immediatedly executed.
This simplifies your rwloadsim code as you do not need to seperate the declaration
and the execution of your SQL statements.
Additionally, implicit bind and define will be enabled by default for
immediate sql.
.P
The immediate sql syntax can be used stand alone to execute single row queries,
DDL, DML or PL/SQL, or it can be used as part of a cursor loop.
.P
As immediate sql does implicit bind and define, the only specifications that
typically would be needed are
.B bindout
for PL/SQL or DML with a returning clause, or 
.B array
to enable the array interface for DML.
The restriction that these two cannot be used together also applies to immediate sql.
.P
The sql text for immediate sql can be a concatenation, which allows for dynamically
generated sql.
However, as rwloadsim does not have a possibility for the programmer to
\fIdescribe\fR the sql to find select list elements and/or bind variables, these
must be "known" to the programmer.
As an example, using 'select *' in a query requires the programmer to know
what the asterisk expadns to and therefore which define variables to declare.
.SH EXAMPLES
.P
.B Simple query
.P
Declare some variables and a simple sql statement using bind by name for its 
bind variable, execute the query and print some output:
.P
.RS 4
.nf
integer empno := 7900;
double sal;
string(20) ename;

sql getemp
  select ename, sal from emp
  where empno=:empno
  /
  bind ":empno" empno;
  define 1 ename, 2 sal;
end;

getemp;

printline "Employee #" empno ", name:" ename ", salary:" sal;
.fi
.RE

.P
.B Declaration and use of cursor
.P
.RS 4
.nf
sql getemps
  select e.ename, e.sal
  , d.loc
  from emp e join dept d
  on e.deptno = d.deptno
  where d.deptno = :1
  and   e.sal > :2;
  bind 1 deptno; bind 2 sallimit;
  define 1 ename, 2 sal;
  define 3 location;
  array 5;
end sql;

for getemps loop
  printline ename, sal, loc;
end loop;
.fi
.RE
.P
.B Implicit bind and define
.P
Declare a procedure showing how implicit bind
and define can be used.
Note that the alias for the select list element
e.sal/12 is 
.I required
as there would otherwise be no simple name
that could be matched to a variable.
.P
.RS 4
.nf
$implicit:both 

procedure printemps(integer deptno)
  string ename, dname;
  integer empno;
  double monthsal;

  sql getemps
    select e.empno, e.ename, d.dname
    , e.sal/12 monthsal
    from emp e join dept d
    on e.deptno = d.deptno
    where d.deptno=:deptno
    /
  end;

  for getemps loop
    printline empno, ename, monthsal, dname;
  end loop;
end printemps;
.fi
.RE
.P
.B Immediate execute of simple query
.P
This is similar to the first example using immediate sql execution.
.P
.RS 4
.nf
integer empno := 7900;
double sal;
string(20) ename;

sql execute
  select ename, sal from emp
  where empno=:empno
  /
end;

printline "Employee #" empno ", name:" ename ", salary:" sal;
.fi
.RE

.P
.B Array for DML
.P
This example shows how to use the array interface for an insert statement.
.P
.RS 4
.nf
integer i;
# assume more variables are declared

sql inslin
  insert into orderlines
  ( ordno, linno, product, amount )
  values
  -- it is fine to use bind by position
  -- also when the actual binds are named
  ( :a, :b, :c, :d)
  .
  # You do not need to have binds in any
  # particular order and
  # can mix bind by position and name
  bind 3 prodcode, 1 ordno;
  bind ":d" amount;
  bind 2 i;
  # Use array of 10 rows
  array 10;
end inslin;

ordno := ... ;
for i:=1 .. linecount loop
  # set values 
  prodcode := ... ; amount := ... ;
  inslin; # fill array and flush each 10 rows
end loop;
commit; # will flush array as needed
.fi
.RE

.B Use of bindout
.P
Directly execute a PL/SQL block having an output bind:
.P
.RS 4
.nf
string datestring;
sql execute
  BEGIN
    :1 := to_char(sysdate,'DD.MM.YYYY HH24:MI');
  END;
  .
  bindout 1 datestring;
end;

printline datestring;
.fi
.RE

.P 
.B Need for comment
.P 
Directly execute a sql statement showing a case where the initial comment characters are
needed as the sql statement itself does not start with one of the keywords
used to initiate scanning for sql.
.P
.RS 4
.nf
sql execute
  /**/ set transaction read only;
end;
.fi
.RE

.P
.B Dynamic sql
.P 
Declare a dynamic sql statement with an array size and an
initial set of define variables
assuming these will always be needed during actual execution.
.P
.RS 4
.nf
sql myquery
  define 1 cola, 2 colb;
  array 42;
end;
.fi
.RE
.SH NOTES
The scan for SQL or PL/SQL starts anywhere where one of the keywords listed above are found.
If this is used at an inappropriate place, i.e. anywhere else than after 
.B sql
.BR identifier ,
or the
.B sql execute
keywords, the rwloadsim parser will report an error.
.SH COPYRIGHT
Copyright \(co 2022 Oracle Corporation
.P
Licensed under the Universal Permissive License v 1.0
as shown at 
https://oss.oracle.com/licenses/upl
.SH "SEE ALSO"
sqlexecution(1rwl), sqlstatement(1rwl), directive(1rwl)
