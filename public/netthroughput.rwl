# RWP*Load Simulator
#
# Copyright (c) 2022 Oracle Corporation
# Licensed under the Universal Permissive License v 1.0
# as shown at https://oss.oracle.com/licenses/upl/
#
# History
# bengsig  13-sep-2022 - Now netthroughput.rwl
# bengsig  28-apr-2022 - Exit on connect error
# bengsig  18-may-2021 - Improve output
# bengsig  09-sep-2020 - Add help text
# bengsig  20-may-2020 - Creation

# This RWP*Load Simulator script it used to test
# the throughput of an Oracle NET connection
# between a client or application server and a 
# database.
#
# You will need a username, password and connect string
# that allows you to connect to your database. The only
# requirement for the user is that it needs to be able
# to execute queries; no tables or other objects will
# be created.
#
# To peform an initial, simple test, execute
#
# rwloadsim -ul username/{password}@db netthroughput.rwl
#
# To get help, execute
#
# rwloadsim -uH netthroughput.rwl
#
# The following options are accepted
# --period=NN      Will use a period of NN seconds for each test
#                  the default is 60
#
# --concurrency=NN Run that many concurrent throughput streams
#                  the default is 1
# 
# --fetcharray=NN  The the array size for the fetch loop, default is 8
#                  implying close to 100kB in each array
#
# --rampup=NN      Ramp-up time for all sessions connect, default 5s
#                  Increase if you get warning about loop starting
#                  after expected start time
#
# --verbosetest    Make the output more verbose

# If we didn't connect, don't do anything
$if not defined(default database) $then
  writeline stderr, "Missing or incorrect -l option; use -h to get help";
  exit 1;
$endif

# Ignore warning about ignoring error
$mute:73 # RWL-073: warning at [demo/connping.rwl;21]: muting non-warning 22
# and ignore the division by zero error
$mute:22 # RWL-022: error at [demo/connping.rwl;109]: attempted division by zero

double dd, d0;

double period := 60;
integer verbosetest := 0;
integer concurrency := 1;
integer fetcharray := 8;
double rampup := 5.0;
integer mbperquery := 1;
string(2048) csvoutput;
string(2048) csvappend;
integer csvexcel := 0;
#string(2048) dumpfile;
#integer dumpcount := 0;

              $userhelp:"netthroughput - Measure Oracle Net throughput from database to client"
              $userhelp:"This utility makes a database connection and runs queries sending large"
              $userhelp:"data amounts back to the client and use that to measure the throughput."
              $userhelp:"You provide a number of concurrent streams doing this and can by increasing"
              $userhelp:"the count get an estimate of the maximum throughput available."
              $userhelp:"If there is access to v$mystat, both physical and logical throughput"
              $userhelp:"will be output; otherwise only logical is available."
	      $userhelp:"-l u/p@c          : Compulsory option providing database credentials"
     $useroption:period:"--period=N        : Set run period, default is 60s"
$userswitch:verbosetest:"--verbosetest     : Make output more verbose"
$useroption:concurrency:"--concurrency=N   : Run this many concurrent throughput tests, default 1"
 $useroption:fetcharray:"--fetcharray=N    : Use this array size, default 8 meaning ~100kB in each array fetch"
     $useroption:rampup:"--rampup=N        : Set rampup period for throughput tests, default is 5s"
 $useroption:mbperquery:"--mbperquery=M    : Change the default of 1MB per query"
  $useroption:csvoutput:"--csvoutput=file  : Write pure csv data to this file"
  $useroption:csvappend:"--csvappend=file  : Append pure csv data to this file"
   $userswitch:csvexcel:"--csvexcel        : Use ';' field separator and CRLF line terminator in csv file"
              $userhelp:"If you create a csv file, it always has four columns:"
              $userhelp:"1: the value of concurrency"
              $userhelp:"2: the logical throughput in MB/s"
              $userhelp:"3: the physical throughput in MB/s or 0 if not available"
              $userhelp:"4: 0 if data is reliable, otherwise the needed rampup"
#  $useroption:dumpfile:"--dumpfile=file   : Write received rows to this file"
# $useroption:dumpcount:"--dumpcount=M     : Stop writing recieved rows after this many"

integer dophys := 1;

$clockstart:0

# Check that we can read v$
integer vdollarval := 0;
sql checkvdollar
  select 42 from
  v$mystat s join v$statname n
  on s.statistic# = n.statistic#
  where n.name = 'bytes sent via SQL*Net to client'
  /
  define 1 vdollarval;
  ignoreerror;
end;

checkvdollar;

if oraerror != 0 or vdollarval != 42 then
  writeline stderr, "No access to v$ tables - only logical throughput measured";
  dophys := 0;
end if;

$oraerror:stop

integer firsttime := 1;

$if concurrency>0 $then

# The thoughput test is based on running a query that generates 
# roughly 1MB of output in 64 rows each with roughly 16KB of
# data.  As the overhead in SQL*Net isn't known, we make the rows
# slightly smaller than 16KB

# First, establish the time used in the database to run the 
# generator query 1000 times

integer x;

sql timequery
  declare
    xx varchar2(16384);
    i number;
    j number;
    rr varchar2(16384);
  begin
    j := 0;
    rr := to_char(1000*dbms_random.value,'FM999.99');
    for i in 1..1000 loop
      for myrow in (
	  select
	    rpad(to_char(ora_hash(sys_guid()),'FM09999999999')||rr||chr(32+mod(rownum,64))
		,16340,chr(33+mod(rownum,64))||'Aw4rXyZi1p+bOd,fg')
	  into xx
	  from dual connect by rownum<=:1*64)
      loop
	j := j+1;
      end loop;
    end loop;
  end;
  /
  bind 1 mbperquery;
end;

double tqsum := 0.0, tqsq := 0.0;

if verbosetest then
  printline "Preparing throughput test...";
else
  printline "Preparations taking up to " mbperquery * 15 " s";
end if;

integer prepcount;

double puredbtime;

execute
  timequery; # To compile the PL/SQL
  prepcount := 4;
  commit; # avoid RWL-046
  for x:= 1..prepcount loop
    d0 := runseconds;
    timequery;
    dd := runseconds - d0;
    tqsum += dd;
    tqsq += dd*dd;
    commit;
    if verbosetest then
      printline "Pure database time for 1000 throughput queries: " dd " s";
    end if;
  end loop;
  puredbtime := tqsum/prepcount;
  printline "Pure database time per throughput query: "
            "mean " puredbtime
	    " ms, stddev " sqrt((tqsq-tqsum*tqsum/prepcount)/prepcount);
end execute;

double tim0, timestart, timestop;

timestart := rampup + runseconds+0.5*concurrency; # allow time for rampup
timestop := timestart + period ;

double threads sum totalmb := 0;
double threads sum totalnetmb := 0;

string(16384) s16k;
# Note that even if rr only contains a few bytes, it is crucial that it
# has a declared length > 4000 bytes. If not, the bind of :1 below
# to rr will be a "short" bind (max 4000) and rpad will subsequently
# also return max 4000 bytes, but we need it to return 16k bytes.
string(16384) rr;

sql sel1m 
  select
    rpad(to_char(ora_hash(sys_guid()),'FM09999999999')||:1||chr(32+mod(rownum,64))
        ,16340,chr(33+mod(rownum,64))||'Aw4rXyZi1p+bOd,fg')
  from dual connect by rownum<=:2*64
  /
  define 1 s16k;
  bind 1 rr, 2 mbperquery;
  array fetcharray;
end;

# use a block to get the session
execute
  # execute once so it ges parsed
  for sel1m loop
    null;
  end loop;

  prepcount := 10;

  tqsum := 0; tqsq := 0;
  for x := 1..prepcount loop
    d0 := runseconds;
    for sel1m loop
      null;
    end loop;
    dd := 1000*(runseconds - d0);
    tqsum += dd;
    tqsq += dd*dd;
    if verbosetest then
      printline "Network and database time for " mbperquery 
        "M query: " dd " ms";
    end if;
  end loop;
  printline "Network and database time for throughput query: "
            "mean " tqsum/prepcount 
	    " ms, stddev " sqrt((tqsq-tqsum*tqsum/prepcount)/prepcount);
  if tqsum/prepcount < 2*puredbtime then
    printline "Warning: pure database time is more than half of total time";
  end if;
end execute;

integer threads sum increaseramp := 0;

procedure exec1mqueries()
  # This procedure expects a session to already be taken
  integer tot := 0;
# file dmp;
# if dumpfile != "" and dumpcount > 0 and threadnumber = 1 then
#   dmp := dumpfile;
# else
#   dumpcount := 0;
# end if;
    

  if runseconds > timestart then
    printline "Thread " threadnumber " starting late at " runseconds ", expected starttime " timestart;
    increaseramp += 1;
  end if;
  if verbosetest then
    printline "Thread " threadnumber " connected";
  end if;
    
  if threadnumber = concurrency then
    printline "All threads connected";
  end if;
  for start timestart stop timestop loop
    if loopnumber = 1 and threadnumber = 1 then
      printline "Actual throughput test now running " period " s";
    end if;
    rr := uniform(0.0,999.9);
    for sel1m loop
      tot += 1;
      # the 40 bytes we add here is purely heuristically taken
      # as the overhead in shipping one row with one column
      totalmb += (40+lengthb(s16k))/1048576.0 ;
#$if dumpcount $then
#     # Only include the code if actually used
#     if threadnumber = 1 and tot <= dumpcount then
#	writeline dmp, s16k;
#     end if;
#$endif
    end loop;
    # totalmb += mbperquery;
  end loop;
# if dumpcount then
#   dmp := null;
# end if;
  if verbosetest then
    fprintf stderr,"Thread %d completed %d %dM loops in %.1fs returning %.0fMB logical bytes\n"
    , threadnumber, tot, mbperquery, runseconds-timestart, totalmb;
  end if;

end procedure;

procedure start1mqueries()
  # this procedure will get the session
  # and the bytes from v$mystat

  double netmb1, netmb2;
  sql qrybytes
    select s.value/1048576 from
    v$mystat s join v$statname n
    on s.statistic# = n.statistic#
    where n.name = 'bytes sent via SQL*Net to client'
    /
  define 1 netmb2;
  end;

  if dophys then
    qrybytes;
    netmb1 := netmb2;
    exec1mqueries();
    qrybytes;
    if verbosetest then
      fprintf stderr, "Thread %d returned %.0fMB physical bytes\n",threadnumber,  netmb2-netmb1;
    end if;
    totalnetmb += netmb2-netmb1;
  else
    exec1mqueries();
  end if;
end procedure;

printline "Connecting sessions";

run
  threads concurrency
    wait 0.5*threadnumber;
    start1mqueries();
  end threads;
end run;

file csvfile;
string csvformat;
integer docsv := 0;
integer doheader := 0;

if csvappend != "" then
  if not access(csvappend, "fr") then
    doheader := 1;
  end if;
  csvfile >>= csvappend;
  docsv := 1;
else
  if csvoutput != "" then
    csvfile := csvoutput;
    docsv := 1;
    doheader := 1;
  end if;
end if;

if docsv then
  if doheader then
    if csvexcel then
      writeline csvfile,"streams;logicalMB/s;physicalMB/s;rampupneed\r";
    else
      writeline csvfile,"#streams logicalMB/s physicalMB/s rampupneed";
    end if;
  end if;
  if csvexcel then
    csvformat := "%d;%.3f;%.3f;%.0f\r\n";
  else
    csvformat := "%d %.3f %.3f %.0f\n";
  end if;
end if; 

if increaseramp then
  if dophys then
    printf "Unreliable throughput estimate %.3f GB/s logical, %.3f GB/s physical\n"
    , totalmb/period/1024.0, totalnetmb/period/1024.0;
  else
    printf "Unreliable throughput estimate %.3f GB/s logical\n"
    , totalmb/period/1024.0;
  end if;
  printline "Rerun with --rampup=" rampup+increaseramp " or higher to ensure all threads are executing concurrently";
  if docsv then
    fprintf csvfile, csvformat, concurrency, totalmb/period, totalnetmb/period, rampup+increaseramp;
  end if;
else
  if dophys then
    printf "Throughput estimate %.3f GB/s logical, %.3f GB/s physical\n"
    , totalmb/period/1024.0, totalnetmb/period/1024.0;
  else
    printf "Throughput estimate %.3f GB/s logical\n"
    , totalmb/period/1024.0;
  end if;
  if docsv then
    fprintf csvfile, csvformat, concurrency, totalmb/period, totalnetmb/period, 0;
  end if;
end if;
if docsv then
  csvfile := null;
end if;

$else
writeline stderr, "Concurrency must be at least 1";
$endif

